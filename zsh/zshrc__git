function git_show_modified_files() {
  local ask_to_commit=${1:-true}
  if [[ $(git status --porcelain) ]]; then
    echo -e "\nüìù \033[0;33mModified files:\033[0m"
    git status --porcelain

    if [[ "$ask_to_commit" == true ]]; then
      echo -e "\nDo you want to commit all modified files? (y/n)"
      read -k 1 -s answer
      echo $answer
      if [[ $answer == "y" ]]; then
        git add .
        git commit -m "lint & format"
        echo -e "\n‚úçÔ∏èüèº \033[0;32mAll modified files have been committed.\033[0m"
      fi
    fi
  fi
}

alias g="gt"

# "git checkout branch"
alias gcob="git co -b"

# "git start": Starts a new branch from the latest version of the development branch
# If I need this again, it needs a new name. It wiped out my work one time üò≠
# alias gs="gcod && gcob"

# "git checkout main/dev"
# Also resets to HEAD, since that's pretty much always what I want when switching to one of these branches. Could also `git fetch` here before resetting to HEAD, but not sure if that's desirable yet + not necessary when in VS Code, since it fetches automatically in the background
# Also prunes local branches that have been merged
# alias gcom="git co \$(git_main_branch) && groh && gbda"
# alias gcod="git co \$(git_dev_branch) && groh && gbda"
gcom() {
  if git_has_changes; then
    echo -e "\n‚ö†Ô∏è \033[0;33mLocal changes would be lost. Please stash them first.\033[0m"
    return 1
  fi
  git co $(git_main_branch) && git reset --hard origin/HEAD
}

gcod() {
  if git_has_changes; then
    echo -e "\n‚ö†Ô∏è \033[0;33mLocal changes would be lost. Please stash them first.\033[0m"
    return 1
  fi

  git co $(git_dev_branch) && git reset --hard origin/HEAD
}
# Should probably only use these when trying to check out files from origin/dev or origin/main
# NOTE: Doing this (at least when the local version of the branch is not up-to-date) will put Git in a "detached head" state -- not just reset the local branch to origin's HEAD)
alias gcoom="git co origin/\$(git_main_branch)"
alias gcood="git co origin/\$(git_dev_branch)"

# "git checkout all"
alias gc.="gco ."

# Override existing git aliases from the oh-my-zsh plugin to all use this custom `gc` alias, which uses `--no-verify`. This allows us to always circumvent pre-commit hooks that slow us down üôàü§∑‚Äç‚ôÇÔ∏è
alias gc="git commit --no-verify"
alias gcm="gc -m"
alias gcam="gc -am"
alias 'gc!'='gc -v --amend'
alias gca='gc -v -a'
alias 'gca!'='gc -v -a --amend'
alias gcam='gc -a -m'
alias 'gcan!'='gc -v -a --no-edit --amend'
alias 'gcans!'='gc -v -a -s --no-edit --amend'
alias gcmsg='gc -m'
alias 'gcn!'='gc -v --no-edit --amend'
alias gcs='gc -S'
alias gcsm='gc -s -m'

# "git commit lazy": Commit all if no staged changes, otherwise commit only staged files. Mirrors VS Code's behavior for commiting
gci() {
  if git diff --cached --quiet; then
    # No files are staged -- commit all unstaged changes
    git add -A -- .
    gc $@
  else
    # Files are staged -- only commit them
    gc $@
  fi
}
# Commit lazy, with a message
# NOTE: A copy of this logic (without using zsh aliases) exists as an executable in `bin` in this repository. See that script for details why
# alias gcim="gci -m"

# "git pull origin main"
# `--no-edit` suppresses editing the commit message when doing the pull as a merge
alias gpom="git pull origin \$(git_main_branch) --no-edit"
# "git pull origin dev"
# `--no-edit` suppresses editing the commit message when doing the pull as a merge
alias gpod="git pull origin \$(git_dev_branch) --no-edit"

# Change "git diff" to ignore whitespace changes by default
alias gd="git diff -w"

# "git diff origin dev"
alias gdod="git fetch && gd origin/\$(git_dev_branch)"
# "git diff origin main"
alias gdom="git fetch && gd origin/\$(git_main_branch)"

# Git diffing with origin/master and origin/<dev_branch>
alias gr="git rev"
alias grem="git remote" # (original oh-my-zsh `gr` alias)

# "git undo": "undoes" the last commit, and puts its changes back into the index
alias gundo="git reset HEAD~"
# "git undo soft/staged": "undoes" the last commit, and puts its changes into the staging area
alias gundos="git reset HEAD~ --soft"

# "git abandon": See gitconfig alias for details
gab() {
  echo
  echo "\033[1;33m‚ö†Ô∏è Warning: This will delete the current branch, and it will be lost forever.\033[0m"
  echo "\033[1;34mü§î Are you sure you want to proceed? (y/N)\033[0m"
  read -k 1 response
  if [[ $response =~ ^[Yy]$ ]]; then
    echo
    git abandon
  else
    echo
    echo "\033[1;31m‚ùå Operation cancelled.\033[0m"
  fi
}

# "git branch modify": Rename a branch
alias gbm="git branch -m"

alias gap="git add --patch"

# Remap oh-my-zsh's default `gup`
alias gpr="git pull --rebase"

# Quick committs with `gitupdate` go package
alias gup="gitupdate ."

# "git publish": Pushes a branch to remote. See .gitconfig for implementation
alias gpub="git publish"
# "git unpublish"
alias gunpub="git unpublish"

# "git fixup": Quick fixup commits
# This one does all files, or just the ones staged, if any
alias gix="gcim 'fixup'"
# Explicitly select all files
alias gixa="gc -a -m 'fixup'"

# "git authors": See how many lines of code each dev/author is responsible for
# Source: https://stackoverflow.com/questions/4589731/git-blame-commit-statistics
alias gauth="git ls-tree -r -z --name-only HEAD -- $1 | xargs -0 -n1 git blame \
--line-porcelain HEAD |grep  '^author '|sort|uniq -c|sort -nr"

# "git merge continue": add all files that had conflicts, and finish the merge (skip editing the commit message, since `true` is working here as a no-op editor)
alias gmc="gaa && GIT_EDITOR=true gc"

# Change "git rebase continue" to skip editing the commit message (since `true` is working here as a no-op editor)
alias grbc="GIT_EDITOR=true git rebase --continue"
# "git rebase next": Add all files and continue the rebase
alias grbn="git add . && grbc"

# "git forget": Remove all files that used to be tracked, but aren't any longer (by gitignore)
alias gforget="git rm -r --cached . && git add ."

# "git conflicts": Show all files with conflicts (does so by using `git diff`, because in the case of rebase/merge conflicts, only conflict files will be in the index)
alias gconflicts="git diff --name-only | uniq"
# "git fix": Open all files with conflicts (in VS Code)
# NOTE: The subshell/cd stuff is to ensure that this works no matter where in the git directory we are (since git diff will spit out paths from the repo root, we need to be in the repo root when we open the files in our editor)
alias gfix="git diff --name-only | uniq | (cd \$(git repo-root) && xargs cursor)"

# "git summary": Show a summary of a commit (i.e. without the diff)
alias gsm="git show --quiet"
# Even less info (i.e. no commit author or time)
alias gsmo="gsm --oneline"

# Pull in latest dev, and run any on-pull scripts in the repo
gsn() {
  gt sn

  local repo_root="$(git repo-root)"
  local brett_dir="$repo_root/.brett"
  local on_pull_script="$brett_dir/bin/on-pull.sh"
  if [[ -d "$brett_dir" && -f "$on_pull_script" ]]; then
    "$on_pull_script"
  fi
}

git_dev_branch() {
  if [[ -n $(git branch --list develop) ]]; then
    echo develop
  elif [[ -n $(git branch --list development) ]]; then
    echo development
  elif [[ -n $(git branch --list main) ]]; then
    echo main
  # Gather uses this
  # elif [[ -n $(git branch --list staging) ]]; then
  #   echo staging
  else
    echo master
  fi
}

###########################################################
# Returns 0 if there are any git changes, 1 if not
#
# Reference: https://stackoverflow.com/questions/3878624/how-do-i-programmatically-determine-if-there-are-uncommitted-changes
###########################################################
git_has_changes() {
  git update-index -q --refresh
  ! git diff-index --quiet HEAD --
}
# "git diff": Diffs the current branch against its parent branch, specified branch, dev branch, or origin dev
# Usage: diff [compare_branch] [--dev] [--origin-dev]
#   - If no compare_branch is provided, it automatically finds the parent branch
#   - If --dev is provided, it compares against the dev branch
#   - If --origin-dev is provided, it compares against the origin dev branch
diff() {
  local current_branch=$(git rev-parse --abbrev-ref HEAD)
  local compare_branch

  if [[ "$1" == "--dev" ]]; then
    compare_branch=$(git_dev_branch)
  elif [[ "$1" == "--origin/dev" ]]; then
    compare_branch="origin/$(git_dev_branch)"
  else
    compare_branch=${1:-$(git show-branch -a 2>/dev/null | grep '\*' | grep -v "$current_branch" | head -n1 | sed 's/.*\[\(.*\)\].*/\1/' | sed 's/[\^~].*//')}
  fi

  local merge_base=$(git merge-base "$current_branch" "$compare_branch")

  echo "üåø Current branch: $current_branch" && echo "üîÄ Comparing against: $compare_branch" && echo "üîó Merge base: $merge_base"

  git diff "$merge_base" "$current_branch"
}

#####################################################################
# Graphite
#####################################################################

submit() {
  if [[ " $* " == *" --squash "* ]]; then
    g squash --no-edit
  fi

  local other_flags=("${@/--squash/}")
  # g submit --publish --no-edit-description --ai ${other_flags[@]}
  g submit --publish --ai ${other_flags[@]}
}
